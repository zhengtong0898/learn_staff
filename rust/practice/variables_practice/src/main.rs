
/****************************************************************************************
  习题3. 作用域是一个变量在程序中能够保持合法的范围
  目标:  修复下面代码的错误并使用尽可能少的改变
  https://zh.practice.rs/variables.html
*****************************************************************************************/
fn main_3() {

    let x: i32 = 10;
    let y: i32;

    {
        y = 5;
        println!("x 的值是 {}, y 的值是 {}", x, y);
    }

    println!("x 的值是 {}, y 的值是 {}", x, y); 

}


/****************************************************************************************
  习题4  无标题
  目标   修复错误
  https://zh.practice.rs/variables.html
*****************************************************************************************/
fn define_x() -> &'static str {
    let x = "hello";
    x
}


fn main_4() {
    let x = define_x();
    println!("{}, world", x);
}


/****************************************************************************************
  习题8  我们可以将 let 跟一个模式一起使用来解构一个元组，最终将它解构为多个独立的变量
  目标   修复下面代码的错误并尽可能少的修改
  提示   使用变量的可变性
  https://zh.practice.rs/variables.html
*****************************************************************************************/
fn main_8_1() {
    let (mut x, y) = (1, 2);
    x += 2;

    assert_eq!(x, 3);
    assert_eq!(y, 2);
}


/****************************************************************************************
  习题8  我们可以将 let 跟一个模式一起使用来解构一个元组，最终将它解构为多个独立的变量
  目标   修复下面代码的错误并尽可能少的修改
  提示   使用变量遮蔽
  https://zh.practice.rs/variables.html
*****************************************************************************************/
fn main_8_2() {
    let (x, y) = (1, 2);
    let x = x + 2;
    
    assert_eq!(x, 3);
    assert_eq!(y, 2);
}


/****************************************************************************************
  习题9  无标题
  目标   修复错误
  https://zh.practice.rs/variables.html
*****************************************************************************************/
fn main_9() {
    let (x, y);
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    // 填空，让代码工作
    assert_eq!([x,y], [3, 2]);
}


fn main(){
    main_3();
    main_4();
    main_8_1();
    main_8_2();
    main_9();
}
